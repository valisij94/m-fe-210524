# README

## Лекционное занятие №22

### Тема:

Репозитарий содержит материалы по лекционному занятию №22, посвященному инкапсуляции в JS, а также свойствам-аксессорам.

**Инкапсуляция**
Сегодня мы поговорим о третьем принципе ООП - инкапсуляции. То есть, о сокрытии каких-то деталей внутри класса. Это может быть часть методов, внутреннее состояние - да что угодно, что нам хотелось бы скрыть.

Зачем это может быть нужно? Например, мы хотим сделать метод класса, который будет вспомогательным (то есть мы предполагаем, что его нужно использовать только внутри класса). Или же, мы хотим задать свойство класса, которым можно управлять только изнутри класса. То есть, мы хотим скрыть реализацию и/или внутреннее состояние.

Вернемся к нашему примеру с прошлого занятия, с животными. У всех наших животных есть свойство `weight`. Пока что, это обычное свойство, которым мы можем управлять извне. То есть, мы можем явно указывать вес нашему животному. Давайте предположим, что нам нужно изменять вес только тогда, когда животное что-то ест. А напрямую изменять вес запрещено. То есть, нам нужно как-то сделать свойство `weight` доступным только внутри класса. Здесь нам помогут приватные свойства и методы.

Что такое приватное свойство/метод? Это пометка метода и/или свойства символом `#`, и после этого он доступен только внутри класса. Пометим у класса `Animal` это свойство.
```
class Animal {

  // отмечаем, что класс Animal имеет приватное свойство #weight.
  #weight;

  constructor(name, weight) {
     this.name = name;
     this.#weight = weight;
  }
}

const animal = new Animal('AnimalName', 100);
animal.#weight = 120; // ошибка
```

Теперь свойство `weight` - приватное, и работать с ним мы можем только внутри класса. Точно так же можно помечать методы.

Давайте определим классу нашего животного метод `eat`, который будет отвечать за прием пищи животным. В аргументах он принимает вес пищи (число), и должен увеличить вес животного на 2% от этого веса пищи. Попробуем реализовать.

```
class Animal {
   // ...

   eat(foodWeight) {
      console.log(`${this.name} eats something, the food weight is ${foodWeight}`);
      this.#weight += 0.02 * foodWeight;
   }
}
```

Чего мы добились такой реализацией? Мы скрыли внутреннее состояние нашего животного (вес), от внешнего мира (от другого кода, снаружи класса). Мы гарантируем, что вес животного будет меняться только если мы его накормим. То есть здесь мы применили прицнип инкапсуляции - скрыли внутреннее состояние внутри класса.

Точно так же работает и с методами, их можно помечать как приватные. Предположим, нашему животному теперь нужно дать возможность сбросить вес. Мы сделаем ему метод `spendCalories`, который будет снижать вес животного на случайное число процентов (от 0 до 1). И предположим, что мы хотим при КАЖДОМ изменении веса животного, это протоколировать - вести журнал изменений веса. В роли журнала у нас пока что будет консоль. Тогда, имеет смысл определить метод `changeWeight`, который будет изменять вес животного на определенное значение (переданное в аргументах), и выводить в консоль нужное сообщение. Этот метод также имеет смысл пометить как приватный - потому что он не нужен "снаружи", чтобы вызывающий код не мог управлять весом животного напрямую, в обход методов `eat`, `spendCalories`.

```
class Animal {
   //...

   #changeWeight(diff) {
      console.log(`Changing weight for ${this.name}, previous weight - ${this.#weight}`);
      this.#weight += diff;
   }

   eat(foodWeight) {
      const weightDiff = 0.02 * foodWeight;
      this.#changeWeight(weightDiff);
   }

   spendCalories() {
      const diff = -1 * Math.random();
      this.#changeWeight(diff);
   }
}
```

Таким образом, мы вынесли функциональность, ответственную за смену веса, в отдельный приватный метод. И мы пользуемся им из других, неприватных методов. Такая архитектура нашего класса, делает вес животного управляемым только через тот интерфейс, который мы предоставили (методы `eat`, `spendCalories`).

**Свойства-аксессоры**
Теперь вопрос, а зачем нам это все, и как работать с приватными свойствами/методами? Здесь нам на помощь приходят т.н. свойства-аксессоры, или же геттеры и сеттеры. Это специальный способ записи свойств, который позволяет:
 - имитировать работу с приватными свойствами
 - реализовывать логику при установке/получении свойств объекта

```
class Animal {

  #weight;

  constructor(name, weight) {
     this.name = name;
     this.#weight = weight;
  }

  get weight() {
    console.log('Call getter for private #weight property')
    return this.#weight;
  }

  set weight(newWeight) {
    console.log('Call getter for private #weight property')
    this.#weight = newWeight
  }
}

const animal = new Animal('AnimalName', 100);
animal.#weight = 120; // ошибка
animal.weight = 120; // все норм
console.log(animal.weight); // 120

```

Мы реализовали свойства-аксессоры. Теперь, мы работаем не напрямую с приватным свойством #weight. Мы определили свойство-аксессор weight, которое позволяет работать с приватным свойством. Разумеется, вовсе необязательно совпадение имен. Мы можем назвать наше свойство-аксессор так, как сочтем нужным. Суть в том, что со свойством-аксессором мы работаем как со свойством, но поведение у него похоже на метод - то есть, при обращении к свойству-аксессору мы вызываем метод, помеченный `set`, а при получении свойства-аксессора - вызываем метод, помеченный `get`.

**Закрепим практикой**
Сегодня реализуем программное обеспечение для кофемашины. Она умеет делать несколько рецептов кофе из определенных ингредиентов (вода, зерна, молоко). Приготовление кофе в нашем случае заключается в смешивании ингредиентов в определенных пропорциях по весу.

1. Реализуем класс `CoffeeRecipe`, который хранит в себе данные о рецепте кофе (то есть о соотношении ингредиентов). В конструкторе, он принимает название рецепта, и пропорции ингредиентов - от 1 до 3 чисел. Первое - это доля воды `waterFraction`, второе - доля зерен `beansFraction`, и третье - доля молока `milkFraction` . Нужно реализовать в конструкторе контроль того, что соотношение пропорций в сумме равно 1 (т.е доля воды + доля зерен + доля молока = 1).
2. Сделаем свойство-геттер `description`, которое позволит получить описание рецепта. Его задача - вернуть строку вида `Recipe ...: water: ..., beans: ..., milk: ...`
3. Сделаем свойства сеттеры для воды, молока и зерен - нужно чтобы при изменении этих свойств сумма долей равнялась 1.
4. Теперь сделаем программное обеспечение для самой кофемашины. У кофемашины есть модель (строка), и объемы отсеков для воды, зерен и молока (числа). Это мы будем передавать в конструкторе. Для хранения, используем свойства `waterLimit`, `beansLimit`, `milkLimit`. Нам понадобится остлеживать состояние кофемашины, т.е. сколько у нас молока, воды и кофе соответственно. Реализуем это через свойства `water`, `beans`, `milk`.
5. Все кофемашины нашего производства имеют общий список рецептов (массив объектов `CoffeeRecipe`). Список рецептов берем такой:
```
const espresso = new CoffeeRecipe('espresso', 0.6, 0.4, 0);
const americano = new CoffeeRecipe('americano', 0.8, 0.2, 0);
const latte = new CoffeeRecipe('latte', 0.4, 0.2, 0.4);
const cappuccino = new CoffeeRecipe('cappuccino', 0.3, 0.2, 0.5);
```

6. Реализуем загрузку ингредиентов. Сделаем это с использованием свойств-сеттеров, `waterStorage`, `beansStorage`, `milkStorage`. При этом, нужно контролировать, чтобы загрузка не превышала объемы отсеков.
7. Теперь осталось реализовать приготовление кофе. Реализуем метод `makeCoffee`, который будет принимать в аргументе название кофе. Он будет возвращать объект, у которого будет свойство с названием напитка. Но при этом, нужно контролировать, что:
 - кофемашина умеет делать такой напиток - т.е. такой кофе есть в списке рецептов.
 - что у нас достаточно ингредиентов для приготовления кофе.
 - если эти условия выполняются - то мы готовим кофе, и уменьшаем кол-во ингредиентов в кофемашине.

Наше ПО оказалось востребованным на рынке, и мы решили его адаптировать под кофе-автоматы. То есть, нам нужно "расширенное" ПО, которое кроме приготовления кофе, еще и умеет работать с деньгами. Нужно чтобы автомат отслеживал количество и сумму вброшенных монет, и при этом имел конечный список номиналов монет, общий для всех автоматов. Прикинем, как мы будем это реализовывать. Задача к обсуждению.

8. Реализуем ПО для кофейного автомата, по мотивам обсуждения выше. Пока что добавляем функциональность по работе с деньгами, т.е. в объекте автомата мы будем хранить сумму брошенных монет, и у нас будет общий для всех автоматов массив с номиналами монет.
9. Реализуем метод `addCoin`. В аргументе, он принимает номинал монеты. Нужно проверить, что монета нам знакома, и если да - добавить ее номинал к текущей сумме.
10. Теперь пришла пора добавить функциональность по работе с деньгами. Наш автомат должен давать нам метод `setCoffeePrice`, который будет принимать в аргументах название напитка и цену. И нужно как-то сохранить это в автомате. Задача также к обсуждению.
11. Реализуем метод `buyCoffee` - он должен готовить нам напиток, и при этом контролировать, что клиент внес достаточно средств.

### Полезные ссылки
 - Русскоязычный гайд по основам [ООП](https://learn.javascript.ru/class). Уже можно читаить весь раздел учебника.
 - Приватные свойства и методы. [Учебник](https://learn.javascript.ru/private-protected-properties-methods).
 - Еще один гайд по [ООП](https://proglib.io/p/uchebnik-po-javascript-oop-na-prostyh-primerah-2022-06-26). Теперь можно читать и раздел про наследование.