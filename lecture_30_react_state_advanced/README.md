# README

## Лекционное занятие №30

### Тема:

Репозитарий содержит материалы по лекционному занятию №30, посвященному подвинутой работе с локальным состоянием компонентов - хуку `useState`.

**Что это и зачем это нужно?**
На прошлом занятии, мы разбирали понятие локального состояния компонента. При этом, ранее мы работали только с состоянием, которое содержит примитивы. Но это отнюдь не все возможности локального состояния - оно может содержать объекты, массивы - короче, нечто не-примитивное. Иногда это бывает нужно - например, если мы хотим хранить в локальном стейте массив с источником данных для списка, и мы также хотим дать возможность менять этот список (добавлять новые элементы, удалять их, редактировать, и т.д.). Об этом (и не только), сегодня и поговорим.

**Хранение не-примитивов в локальном стейте**
Фактически, хранение не-примитивов в локальном стейте ничем не отличается от хранения примитивов - синтаксис будет ровно тот же. Основная разница будет в изменении значения этого стейта.

Рассмотрим пример. Пусть у нас есть компонент `Human`, у которого есть локальное состояние, которое содержит массив с содержимым карманов. Попробуем добавить еще функции для управления.

```
import { useState } from 'react';

function Human( { humanName} ) {

  const [input, setInput] = useState(''); // это для инпута, в который будем вводить названия вещей чтобы положить в карман
  const [pockets, setPockets] = useState( ['phone', 'keys'] ); // по умолчанию в карманах телефон и ключи

  const addSomething = () => {
    // Кладем в карман
    pockets.push(input);
  }

  // Обработчик события ввода чего-то в инпут
  const handleInputChange = (e) => {
    setInput(e.target.value);
  }

  return (
    <div>
      <h3>Human, my name {humanName}</h3>
      {
        pockets.map(thing => <p key={thing}>{thing}</p>)
      }
      <input type='text' value={input} onChange={setInput}/>
      <button onClick={addSomething}>Add something</button>
    </div>
  )
}
```

Вроде все логично. Но при такой реализации, работать оно будет некорректно. Мы введем нечто в инпут, нажмем кнопку, и ничего не изменится. Изменения мы увидим только тогда, когда опять что-то изменим в инпуте. Нехорошее поведение, почему так?

Потому что наша функция `addSomething` МУТИРУЕТ массив, который лежит в локальном стейте. То есть, она не создает новый массив, а изменяет существующий! И в силу того, что фактически, массив остался тот же (то есть это один и тот же объект в памяти), реакт принимает решение, что ему не нужно перерисовывать компонент.

Побороть эту ситуацию можно двумя путями.

Первый вариант - создать на месте новый массив.
```
  const addSomething = () => {
    // создаем новый массив, в который сложим текущее содержимое карманов, и добавим значение из инпута
    const newPockets = [ ...pockets, input ];
    // обновим локальное состояние. Мы туда пишем НОВЫЙ массив, поэтому реакт будет перерисовывать наш компонент
    setPockets(newPockets);
  }
```

А есть второй вариант, по сути тот же, но чуть короче. О нем сейчас и поговорим.

**Создание нового стейта на основе предыдущего**
Очень часто, нам нужно создать новый стейт на основе предыдущего. При этом, данные из старого стейта будут как-то использованы при создании нового. Например, как в предыдущем примере, с новым массивом. Это можно делать так, как показано выше. Но второй (и более правильный) вариант - это использование функции управления состоянием с аргументом-колбэком.
```
setState( oldState => {
  const newState = // ...
  // do something with oldState, generate newState based on old one
  return newState;
})
```

То есть, теперь наша функция `setState` будет принимать не новое значение фрагмента локального стейта, а функцию-колбэк, которая в аргумент примет старое значение стейта, и должна вернуть новое значение стейта.

Попробуем переписать нашу функцию из компонента `Human`.
```
  const addSomething = () => {
    setPoclets( oldPockets => {
      return [ ...oldPockets, input ];
    })
  }
```

Так чуть короче (можно и еще короче), но суть одна и та же - фактически, мы создаем новый массив, и в него кладем то, что должно быть в новом стейте.

С объектами работает абсолютно точно так же. То есть, если в локальном стейте лежит объект, то вместо того, чтобы как-то менять его свойства, мы должны создать НОВЫЙ объект, с нужными значениями свойств.

**Закрепим практикой**
1. В файле `MountainRoute` создана заготовка компонента, он должен отрендерить маршрут к Одинокой Горе. Точки маршрута хранятся в массиве в компоненте, перенесите их в локальный стейт. Компонент должен отрендерить каждую точку маршрута в виде div-а, в котором будет параграф с названием локации. И все это оберните в div с классом `lonelyMountainRouteContainer`.
2. Добавляем возможность управления маршрутом. В компонент, под список точек, добавьте инпут с плейсхолдером `New point`, и кнопку `Add point`. Нужно сделать так, чтобы при нажатии на кнопку, значение из инпута добавлялось бы в массив точек маршрута.
3. Теперь добавим валидацию. Нужно сделать так, чтобы при нажатии на кнопку, если в инпуте пустой текст, под ним рисовался бы параграф с текстом `Unknown location!`. Задача к обсуждению.
4. Добавляем кнопку "Remove last location". При клике на нее, нужно удалить из списка последнюю точку.
5. Немного усложним. Нам нужно добавить обработчик на кнопку `Remove location` на каждой точке локации. Нужно, чтобы при клике на эту точку, локация удалялась бы из списка.

**Поднятие состояния**
Очень часто нам нужно сделать так, чтобы состояние делилось бы между несколькими компонентами, на разных уровнях иерархии. Например, есть форма авторизации, где пользователь авторизуется. И нужно, чтобы имя этого пользователя отобразилось в другом компоненте (например, в компоненте приветствия). Фактически, это разные компоненты, а нам нужно сделать так, чтобы они "делили" между собой состояние. Существует ряд вариантов для решения этой проблемы, сегодня мы поговорим о простейшем из них - поднятии состояния (lifting state).

Идея заключается в том, что необходимый фрагмент состояния "поднимается" по иерархии компонентов до ближайшего общего предка в иерархии компонентов, и пробрасывается через пропсы в необходимые компоненты.

Пока не особо понятно. Попробуем на примерах. Пусть у нас есть компонент, который занимается отрисовкой ToDoList-a, то есть списка дел. Для каждого дела он рисует карточки. Список дел держим в локальном стейте.

```
export default function TodoList() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);

  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
    </div>
  );
}
```

Ничего сверхсложного. Теперь предположим, что мы хотим добавить возможность удалять дела в порядке поступления (т.е. удалять последнее дело). Тоже ничего сложного - добавим кнопку и соответствующий обработчик.
```
export default function TodoList() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);
  const dropTodo = () => {
    setTodos( oldTodos => {
      const newTodos = [...oldTodos];
      newTodos.pop();
      return newTodos;
    });
  }
  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
      <button onClick={dropTodo}>Drop last todo</button>
    </div>
  );
}
```

Тоже пока все норм. А теперь представим, что мы хотим создать отдельный компонент, который будет рендерить статистику по делам. Пока что вся статистика сводится к отображению количества актуальных дел. И мы хотим по какой-то причине оформить это как отдельный компонент.
```
export default function TodoStats() {

  return (
    <div>
      <p>Now we have {todos.length} todos!</p>
    </div>
  )
}
```

Все бы ничего, но откуда этот компонент должен узнать о списке дел, который является внутренним состоянием другого компонента?

Правильный ответ - мы должны передать этому компоненту список дел в пропсах! Но тогда получается, что компонент `TodoList` должен отрисовывать компонент `TodoStats`! А что если мы хотим разместить их на одном уровне иерархии, например в компоненте `App`?

Вот в этом случае, нам на помощь придет подъем состояния. Наша задача - поднять "источник данных", то есть локальное состояние, на уровень ближайшего общего предка. В нашем случае, это компонент `App`. И мы, в этом случае, перенесем фрагмент локального стейта в `App`, определим там методы для управления этим состоянием (удаление последнего дела, добавление новых, и т.д.), и прокинем это через пропсы в те компоненты, которые в этом нуждаются. Итого, все будет выглядеть так:

```
import React, { useState } from 'react';

export default function App() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);

  const dropTodo = () => {
    setTodos( oldTodos => {
      const newTodos = [...oldTodos];
      newTodos.pop();
      return newTodos;
    });
  }

  return (
    <div className='App'>
      <TodoList todos={todos} dropTodo={dropTodo} />
      <TodoStats todosCount={todos.length} />
    </div>
  )
}

// TodoList.jsx
export default function TodoList({todos, dropTodo}) {

  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
      <button onClick={dropTodo}>Drop last todo</button>
    </div>
  )
}

// TodoStats.jsx
export default function TodoStats( {todosCount} ) {

  return (
    <div>
      <p>Now we have {todosCount} todos!</p>
    </div>
  )
}
```

**ВАЖНО!**
Нужно поднимать состояние до БЛИЖАЙШЕГО общего предка. Если состояние без надобности поднимается выше - это влечет лишние ререндеры, и пробрасывание фрагментов этого состояния через компоненты, которые в нем не нуждаются. Помним правило "каждый знает столько, сколько ему положено".

**Закрепим практикой**
1. Пристрелочная. Делаем компонент `LoginForm`, который будет отвечать за попытку авторизации. В нем должны быть 2 инпута, для ввода логина и пароля, и кнопка `Enter`.
2. При нажатии на кнопку, нужно проверить, что оба поля непустые. Если оба непустые - то выводим в консоль логин и пароль. Если пустые - нужно, чтобы над кнопкой показывалось бы сообщение об ошибке "Заполните все поля!". Сообщение показываем в виде параграфа. Здесь нам пригодится условный рендеринг.
3. Теперь научим нашу форму авторизации делиться данными. В компоненте `App`, есть заголовок, `SimpleHeader`. Нужно, чтобы при вводе корректных данных (логина и пароля) в форму `LoginForm`, в заголовке появлялся бы текст "Hello, LOGIN". То есть, нам нужно сделать состояние `LoginForm` доступным для `SimpleHeader`, и в этом нам поможет поднятие состояния.
4. Для компонента `TodoList`, реализуйте удаление дел "прицельно". Нужно чтобы при клике на дело (параграф), оно удалялось бы из списка.
5. Реализуйте компонент `AddTodo`, с помощью которого можно будет добавлять новые элементы в список дел.
6. Реализуйте редактирование дел в списке. Добавьте на каждый элемент списка кнопку "Редактировать" (получается, теперь надо рендерить их в виде div-ов, которые будут содержать параграф с названием дела, кнопку "Удалить", и кнопку "Редактировать"). Когда пользователь нажимает на нее, нужно чтобы в инпуте в `App` появлялся бы текст этого дела, и при нажатии на кнопку сохранения, мы бы не добавляли новое дело, а меняли существующее.

### Полезные ссылки
 - Описание [идеи локального состояния](https://react.dev/learn/state-a-components-memory) в документации React.
 - [Описание хука useState](https://react.dev/reference/react/useState) в React. Это именно документация по хуку. Теперь читаем полностью.