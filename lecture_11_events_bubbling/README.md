# README

## Лекционное занятие №11

### Тема:

Репозитарий содержит материалы по лекционному занятию №11, посвященному погружению и всплытию событий в JS.

**Определение погружения/всплытия событий**
Как мы недавно выяснили, на странице в JS постоянно происходят какие-то события. Клики/скроллы/события клавиатуры/фокусы/перемещения мыши - великое множество событий. И мы выяснили, что каждый раз при наступлении какого-либо события, создается объект события (Event), который содержит в себе массу полезной информации: детали события, где оно произошло, и многое другое. Сегодня мы более детально разберем, как ведет себя этот объект при наступлении события.

Разберем все на примере. Предположим, у нас есть фрагмент разметки:
```
<html>
   <body>
      <div id='container'>
         <button id='button'>Click Me!</button>
      </div>
   </body>
</html>
```

И также у нас есть скрипт, который добавляет обработчик события клика на некоторые DOM-узлы.

```
const container = document.querySelector('#container');
const button = document.querySelector('#button');

body.addEventListener('click', (event) => {
   console.log('Clicked on body!');
   console.log(event);
});

container.addEventListener('click', (event) => {
   console.log('Clicked on container!');
   console.log(event);
});

button.addEventListener('click', (event) => {
   console.log('Clicked on button!');
   console.log(event);
});
```

Обратите внимание, мы добавляем обработчики на body, div, и на кнопку.

Теперь кликнем по кнопке. В консоли, мы можем заметить, что сработали все 3 обработчика. Первым сработал обработчик на кнопке, вторым - на контейнере, и третьим - на body.

Почему так произошло? За счет того самого всплытия. Рассмотрим конкретнее. Когда мы кликаем по кнопке, то целевым элементом (то есть, тем элементом, на котором происходит событие), является как раз кнопка. Но кнопка не висит в воздухе - она находится в иерархии DOM-элементов. И порядок такой: html -> body -> div -> button. После того, как событие оказывается на целевом элементе, оно начинает обратный путь - то есть идет вверх по DOM-иерархии, до самого верхнего элемента. Поэтому сработали все наши обработчики. И сработали они в обратном порядке. То есть, объект события "всплывает" по иерархии DOM-элементов, как пузырек воздуха (отсюда термин "всплытие"). При этом, объект содержит все данные о событии.

**ВАЖНО!** Не все события всплывают! Например, событие `blur`, то есть событие утери фокуса, не всплывает!

**Получение целевого элемента, и текущего элемента**
С учетом того, что события всплывают, и каждое событие содержит информацию о деталях события, есть возможность всегда точно понять, какой элемент был целевым (то есть где конкретно произошло событие). За это отвечает свойство `event.target`. Оно указывает на "целевой" элемент.

Также, в событии есть свойство `currentTarget`. Это тоже очень полезное свойство, и оно указывает на тот элемент, на котором СЕЙЧАС выполняется обработчик. В примере выше, это могло бы выглядеть так:

```
const container = document.querySelector('#container');
const button = document.querySelector('#button');

body.addEventListener('click', (event) => {
   console.log('Clicked on body!');
   console.log(event.currentTarget); // body
});

container.addEventListener('click', (event) => {
   console.log('Clicked on container!');
   console.log(event.currentTarget); // div#container
});

button.addEventListener('click', (event) => {
   console.log('Clicked on button!');
   console.log(event.currentTarget); // button#button
});
```

То есть, если мы обрабатываем событие, то мы можем получить ссылки:
 - на целевой элемент, то есть тот элемент, где событие произошло
 - на текущий элемент, на ком сейчас выполняется этот обработчик

**Где и как используется всплытие**
И наконец, самое важное - где и зачем используется всплытие событий в JS. Самый основной прецедент использования - это прием под названием "делегирование событий". Это прием, при котором элементы-потомки делегируют обработку событий родителям. То есть, вместо того, чтобы вешать много обработчиков одного и того же события на конкретные элементы, мы повесим только один обработчик на элемент, который является общим предком всех этих конкретных элементов. Тогда, произошедшее на этих элементах событие будет всплывать, и будет обработано обработчиком на предке. То есть, потомки ДЕЛЕГИРОВАЛИ обработку события предку.

Это может быть использовано, например, для аналитики. Предположим, вам нужно определить наиболее кликабельные зоны на сайте - то есть, вас интересует по каким частям вашего сайта пользователи кликают чаще, а по каким - реже. Можно навесить обработчик события клика на каждый DOM-узел сайта - но это долго и некрасиво. А можно сделать проще, и делегировать обработку этого события их общему предку - например, `document`, или `body`. Таким образом, мы добавляем только один обработчик, которому делегирована обработка всех кликов.

Разумеется, это никак нас не лимитирует по добавлению других каких-то обработчиков кликов на целевые элементы.

```
document.addEventListener('click', (event) => {
   console.log('Click happened!');
});
```

И вот здесь, после делегирования, нам может быть полезен тот факт, что объект события содержит информацию о событии. Ну например, мы хотим отслеживать только клики по кнопкам. Не вопрос - нужно просто отсекать те события, у которых в `event.target.nodeName` указано НЕ `BUTTON`. Или мы хотим ловить только события по элементам с каким-то признаком - тоже проверим его в обработчике.

**Закрепим практикой**
1. В DOM добавлен блок `div#bubblingBlock`. В нем есть кнопки с разными текстами. Нужно сделать так, чтобы при клике на кнопки или параграфы, в консоль выводилось сообщение `Clicked inside bubblingBlock`.
2. Усложняем задачу. Теперь ужно сделать так, чтобы при обрабатывались только клики на кнопки.
3. Еще усложняем. При клике на кнопки, в консоль нужно выводить сообщение "Кликнута кнопка ТЕКСТ_КНОПКИ". То есть, нам нужен `textContent` целевого элкемента.
4. Теперь мы хотим реагировать на клики на параграфы в блоке `bubblingBlock`. При клике на параграф, в консоль должно выводиться сообщение `Clicked on paragraph!`.
5. Фильтруем клики. Теперь нужно реагировать на клики по тем параграфам, у которых есть класс `simpleParagraph`.
6. Усложняем задачу. Предположим, мы хотим "протоколировать" все клики мыши на странице. При каждом клике, нам нужно выводить в консоль тип DOM-узла, по которому кликнули. Подсказки:
 - нам нужно обрабатывать события на уровне документа, т.е. добавить ОДИН обработчик.
 - для получения типа узла, используем свойство `nodeName` элемента.
7. Работаем с текстовым полем `input#testInput`. Наша задача - протоколировать нажатие каждой кнопки (выводить в консоль ее код).
 - нужен обработчик события нажатия кнопки на инпут. Событие - `keydown`
 - в объекте события, есть свойство `charCode` - это код нажатой кнопки. Его нужно вывести в консоль.
8. Пишем свою функцию валидации для инпута, назовем ее `validateInput`. Предположим, мы вводим количество единиц товара, и у нас разрешенные символы - только цифры. Наша задача - запретить ввод в текстовое поле не-цифровых символов.
 - нужен обработчик на `keydown` текстового поля - это будет наша функция `validateInput`
 - при обрабокте события, проверяем `event.charCode`.
 - коды клавиш-цифр - от 48 до 57.
 - здесь нам нужно ПРЕДОТВРАТИТЬ стандартное поведение (т.е. изменение текста инпута).

**Предотвращение всплытия**
Есть еще один важный момент, о котором стоит говорить в контексте всплытия. Его можно предотвратить. То есть, в каком-то обработчике сказать, что событие дальше всплывать не должно. Для этого, есть метод `event.stopPropagation`. Рассмотрим наш ранее представленный пример

```
const container = document.querySelector('#container');
const button = document.querySelector('#button');

body.addEventListener('click', (event) => {
   console.log('Clicked on body!');
});

container.addEventListener('click', (event) => {
   console.log('Clicked on container!');
   event.stopPropagation(); // предотвращаем дальнейшее всплытие
});

button.addEventListener('click', (event) => {
   console.log('Clicked on button!');
});
```

Как мы видим, в этом примере мы предотвращаем вспытие на элементе `container`. Поэтому, обработчик на `body` вызван НЕ будет.

**Важный момент**: не нужно предотвращать всплытие без внятной аргументации причин такого решения. Почему: когда вы предотвращаете всплытие, вы создаете "мертвую зону" над элементом. И всякие скрипты-аналитики, SEO, и так далее, не получат данных по событиям из этой зоны. Нам это не нужно. Если вам нужно сделать так, чтобы обработчик игнорировал события в какой-то ситуации - лучше воспользуйтесь условным оператором.

Пример: Делаем "скрытую" от нашего протоколирования кнопку. Нужно, чтобы при клике на кнопку First Button наш обработчик из 3-й задачи не срабатывал. Нам нужно на конкретно эту кнопку добавить обработчик, который предотвратит вплытие.
```
const btn = document.querySelector('#firstButton');
btn.addEventListener('click', event => event.stopPropagation());
```

Теперь события клика по первой кнопке не дойдут до делегата обработчика.

**Жизненный цикл события**
В завершение, разберем по деталям ВЕСЬ жизненный цикл события. Кроме фазы всплытия, которую мы подробно разобрали, у события существуют еще две фазы, погружение и цель. Итого, жизненный цикл события выглядит так:
 - погружение (capturing). Объект события идет вниз по всей DOM-иерархии до целевого элемента
 - цель (target). Объект события "случился" на целевом объекте
 - всплытие (bubbling). Объект события идет вверх по DOM-иерархии, от целевого элемента до `document`.

Все обработчики, которые мы рассматривали, по умолчанию выполняются на фазе всплытия. Но можно принудительно попросить обработчик выполниться на фазе погружения. Для этого, третьим аргументом `addEventListener`, нужно передать `true`.
```
const btn = document.querySelector('#firstButton');
btn.addEventListener('click', event => console.log('Click on the button!'), true);
```

Теперь событие обрабатывается на фазер погружения. И на фазе всплытия, этот обработчик НЕ сработает.


### Полезные ссылки
 - Описание формата (JSON)[https://habr.com/ru/articles/554274/]
 - Англоязычный хороший (источник)[https://www.freecodecamp.org/news/event-bubbling-and-event-capturing-in-javascript/] про event bubbling/capturing
