# README

## Лекционное занятие №40

### Тема:

Репозитарий содержит материалы по лекционному занятию №40, посвященному работе с библиотекой `reduxjs/toolkit`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Мотивационная часть, зачем это нужно
Как мы уже знаем, редакс - штука синхронная. То есть, инициирование изменения стейта через диспатчинг экшнов, работа редьюсера, и уведомление компонентов об изменении состояния - это цепочка синхронных действий. Все бы ничего, но иногда нам может быть нужно выполнить асинхронное действие. Или выполнить несколько действий, и мы захотим перенести эту логику из компонента. Здесь нам помогает т.н. `middleware` - то есть "некое программное обеспечение, встроенное между". Имеется в виду, между диспатчем экшна и работой редьюсера. Таких мидлваров существует несколько, самым простым является `redux-thunk`, окторый мы и рассмотрим.

В нашем проекте, мы уже используем библиотеку `@reduxjs/toolkit`, которая уже содержит в себе этот мидлвар, и функция `configureStore` подключает его по умолчанию, то есть нам не нужно никаких дополнительных действий.

А вот для работы с ним в ЧИСТОМ редаксе (БЕЗ @reduxjs/toolkit), нужно его отдельно установить командой `npm install redux-thunk`. И потом применить мидлвар при создании стора функцией `applyMiddleware`.

### Логика работы
Работает все довольно просто. Суть в том, что мы создаем, например, асинхронные экшны специальным образом, и также специальным образом их обрабатываем редьюсером.

Отличие асинхронного экшна в том, что он возвращает ФУНКЦИЮ а не объект, в который будет передана функция `dispatch`. Эта функция может выполнить какую-то асинхронную логику, и затем задиспатчить обычный экшн. Так все работает в ЧИСТОМ редаксе. В редакс тулкит, есть более удобная возможность работы: есть специальная функция `createAsyncThunk`, которая должна создать промис, который будет резолвиться нужными нам данными. А в слайсе, мы объявим специальные обработчики.

Пока ничего не понятно, поэтому попробуем разобрать на примере. У нас есть слайс состояния, `todoSlice`. Ранее, список дел был локальным. Давайте теперь загружать его "с бэка", с адреса `https://dummyjson.com/todos`. И реализуем эту логику в виде асинхронного экшна.

Для этого, нам нужно вписать в слайс немного дополнительного кода.

```
// src/redux/slices/todosSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

export const fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {
  const response = await fetch('https://dummyjson.com/todos');
  const todos = await response.json();
  return todos.todos;
})

export const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    todos: [],
    filters: null,
    status: 'idle',
    error: ''
  },
  reducers: {
    addTodo: (state, action) => {
      state.todos.push(action.payload);
    },
    dropTodo: (state, action) => {
      state.todos = state.todos.filter(el => el !== action.payload)
    },
    applyFilters: () => {},
    clearFilters: () => {}
  },
  extraReducers: builder => {
    builder
      .addCase(fetchTodos.pending, (state, action) => {
        state.status = 'loading'
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.todos = action.payload
        state.status = 'idle'
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.error = action.payload
        state.status = 'idle'
      })
  }
});

// Action creators are generated for each case reducer function
export const { addTodo, dropTodo } = todosSlice.actions

export default todosSlice.reducer
```

Здесь есть очень много нового, попробуем разобраться со всем по порядку.

1. У нас есть новый "подопытный" - `createAsyncThunk`. Это функция из `@reduxjs/toolkit`, которая собственно под капотом создает асинхронный экшн. Эта функция принимает 2 аргумента: первый - это имя асинхронного экшна (для последующего облегчения отладки), а второй - функция, которая должна возвращать промис. Этот промис будет завершен (успешно или неуспешно - не столь важно), и обработчиком результата будет наш редьюсер (см.п.2). Важный момент: эта функция может принимать аргументы, о них чуть позже.
2. Новое свойство у слайса: `extraReducers`. Это свойство - типа "дополнительные" редьюсеры, которые создаются особым образом. В нашем случае, мы делаем это через функцю-колбэк, она будет принимать на вход объект-"строитель" (builder), и он будет "строить" редьюсер. У этого объекта есть свойство `addCase` - оно как бы добавляет рассмотрение экшна редьюсером. И здесь мы можем указать данные нашего промиса. Как мы помним, у промиса есть 3 статуса: fulfilled, rejected, pending, и вот как раз их мы рассмотрим в нашем редьюсере.

### Экшны с параметрами
Иногда, возникает необходимость передать какие-то аргументы. Например, мы хотим запросить данные по конкретному `todo`, и для этого нам нужно передать его идентификатор. В этом случае, мы также можем создать асинхронный экшн, который будет принимать аргументы. Рассмотрим на примере.

```
export const fetchTodoById = createAsyncThunk('todos/fetchTodoById', async (todoId) => {
  const response = await fetch('https://dummyjson.com/todos/' + todoId);
  const todoData = await response.json();
  return todoData;
})
```

Если нам нужно передать больше одного значения, то нам нужно будет обернуть это в объект. Потому что функция (второй аргумент createAsyncThunk), может принимать только 2 аргумента - первый это то, что нужно для экшна, а второй - это данные редакса.

Теперь поговорим подробнее о втором аргументе. Иногда бывает, что нам нужно в таком асинхронном экшне выполнить ЕЩЕ один экшн. Или получить доступ к текущему стейту. Например, мы запрашиваем данные с бэка, и хотим их запрашивать только если в стейте у пользователя есть полномочия. Разумеется, это можно проверить и в компоненте - а можно сделать и здесь. Или, например, после успешного запроса данных о делах, мы хотим задиспатчить какой-нибудь другой экшн - например, разблокировать интерфейс. И вот тут нам пригодится второй аргумент createAsyncThunk.

```
export const fetchTodoById = createAsyncThunk('todos/fetchTodoById', async (todoId, thunkApi) => {
  const currentState = thunkApi.getState();
  if (currentState.hasPriviliges) {
    const response = await fetch('https://dummyjson.com/todos/' + todoId);
    const todoData = await response.json();
    thunkApi.dispatch( someOtherActionCreator() );
    return todoData;
  } else {
    return Promise.reject('No priviliges');
  }
})
```

То есть мы можем из экшна получить доступ к текущему стейту, и/или задиспатчить другой экшн.

### Закрепим практикой
В качестве практики, нам предстоит переписать логику работы со списком товаров на использование `@reduxjs/toolkit`. Нужно создать слайс для товаров, там сделать асинхронный экшн, и научить наши компоненты с ним работать.

### Полезные ссылки
[Quick Start](https://redux.js.org/usage/writing-logic-thunks) - официальная документация.
[Описание createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk) - полезно, но там примеры на TypeScript, так что код не смотрим, читаем только спецификацию аргументов.