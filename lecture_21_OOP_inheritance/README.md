# README

## Лекционное занятие №21

### Тема:

Репозитарий содержит материалы по лекционному занятию №21, посвященному наследованию в JS.

**Зачем это нужно**
В основах подхода объектно-ориентированного программирования лежит несколько понятий, это:
 - инкапсуляция - это принцип, который исповедует сокрытие внутреннего состояния и реализации поведения объекта внутри него, и выставление "наружу" только того, с чем предполагается взаимодействие.
 - полиморфизм - возможность реализации наследуемых свойств или методов разными способами в разных потомках.
 - наследование - расширение потомками функциональности родителей.
 - абстракция - моделирование требуемых атрибутов и взаимодействий сущностей в виде классов для определения абстрактного представления системы.

Пока ясности особо нет. Попробуем на примерах. Начнем с самого простого - с наследования, которое является базой для всего остального.

### Наследование
Предположим, мы пишем программное обеспечение для работы с животными. У нас есть сущность (класс) "Animal" - которое нам представляет некое абстрактное животное, без конкретики. В этот класс мы добавим те свойства и методы, которыми обладают все животные. Например, добавим свойства `name`, `weight` - у каждого животного есть имя и вес.

Двигаемся далее. Каждое животное теоретически издает какой-то звук. То есть, нам нужно определить метод `makeSound`.

А теперь перейдем к конкретным животным. Рассмотрим, например, собаку и попугая.

Что может делать собака, что не может делать рыбка и/или попугай? Например, бегать. Попугай может летать. Рыбка может плавать. То есть, мы видим, что у нас вырисовываются новые классы, `Dog`, `Fish`, `Parrot`. Но в то же время, все они являются животными - то есть имеют имя и вес. Как это реализовать?

Конечно, можно определить соответствующие свойства в каждом классе. Но не лучше ли как-то сказать "собака имеет свои свойства и методы, характерные только для нее. Но в то же время является и животным, то есть имеет свойства и методы из класса животного". И то же самое для рыбки и попугая. Так гораздо лучше - это делает нашу архитектуру приложения гораздо более гибкой. К примеру, мы захотим добавить новое свойство, которое будет обязательно для всех животных - например, дата рождения. С использованием наследования, мы его добавим в общего предка (`Animal`), то есть напишем один раз, и оно будет у всех потомков. А без использования наследования, придется добавлять в каждого потомка, и следить, чтобы нигде не опечататься. Такое себе..

Наследование в JS реализуется с помощью ключевого слова `extends`. Когда говорят что класс Б наследует класс А, это значит, что класс Б имеет доступ ко всем свойствам и методам класса А (за небольшим исключением, о нем поговорим позже, в разделе инкапсуляции).

```
class Animal {

   constructor(name, weight) {
      this.name = name;
      this.weight = weight;
   }
}

class Dog extends Animal {} // класс Dog является наследником класса Animal

// Объекты класса Dog будут иметь свойства name, weight
```

Предположим, мы хотим задать нашему классу `Dog` дополнительное свойство `kind`, то есть породу собак. Этим он будет отличаться от класса животного. Также определим класс попугая, который будет иметь свойство, умеет ли попугай говорить (`canSpeak`).
Возникает логичный вопрос: а какие значения свойств `name`, `weight` будут у объектов класса `Dog`? И вот тут мы приходим к еще одному важному ключевому слову `super`.

Суть в том, что когда мы вызываем конструктор класса-наследника, JS "под капотом" должен вызвать конструктор класса-родителя. И мы должны определять конструктор наследника таким образом, чтобы он передавал в конструктор родителя нужные аргументы. На нашем примере, когда мы хотим создать собаку, мы должны в конструктор собаки передать не только породу, но еще и имя, и вес. И конструктор класса-потомка должен вызвать конструктор класса-родителя. А для этого как раз и есть ключевое слово `super`.

```
class Animal {

   constructor(name, weight) {
      this.name = name;
      this.weight = weight;
   }
}

class Dog extends Animal {

   constructor(name, weight, kind) {
      super(name, weight); // вызываем конструктор родителя, то есть создаем объект "Животное"
      // После вызова конструктора родителя, мы определяем свойства объекта именно этого класса (то есть те свойства,
      // которые не представлены в родителе)
      this.kind = kind;
   }
}

class Parrot extends Animal {

   constructor(name, weight, canSpeak) {
      super(name, weight); // вызываем конструктор родителя, то есть создаем объект "Животное"
      // После вызова конструктора родителя, мы определяем свойства объекта именно этого класса (то есть те свойства,
      // которые не представлены в родителе)
      this.canSpeak = canSpeak;
   }
}
```

**ВАЖНЫЙ МОМЕНТ!** В конструкторе потомка мы ДОЛЖНЫ вызывать конструктор родителя.
**ЕЩЕ БОЛЕЕ ВАЖНЫЙ МОМЕНТ!!!** Запрещено множественное наследование. То есть один класс может быть потомком только одного родителя!

Итого, делаем промежуточные выводы по тому, зачем нужно наследование.
 - Наследование нужно для расширения функциональности классов-родителей. То есть, когда мы хотим сохранить свойства родителя, но добавить что-то новое.
 - В рамках наследования, у нас появляются 2 новых ключевых слова. `extends` - для указания отношения "наследование" между классами, и `super` - для работы с объектом класса-родителя из класса-потомка. Пока что мы разобрали только один кейс использования слова `super` - для обращения из конструктора-потомка к конструктору-родителю, но есть и еще варианты, о них позже.
 - когда мы просим JS создать объект класса-потомка, он обязательно должен создать объект класса-родителя. Поэтому, в конструкторе потомка мы обязательно вызываем конструктор родителя, с помощью `super`.

**Закрепим практикой**
1. Работаем в контексте игры про гномов, эльфов и прочих хоббитов. Задача - определить класс `Human`, который будет содержать данные о существе нашей игры. У него есть свойства `name` (логин пользователя), `fraction` - фракция/раса. И каждый пользователь умеет здороваться - добавим ему метод `greet`, который будет выводить в консоль сообщение вида `Hello, I am _LOGIN_, from _FRACTION_`.
2. Делаем класс `Hobbit`. Каждый хоббит также является существмо нашей игры. При этом, у хоббита есть свойство `homeWillage`, где указана родная деревня хоббита, и свойство `bag`, которое содержит массив вещей, которые хоббит носит с собой.
3. Делаем класс `Dwarf`. Гномы также являются существами нашей игры, при этом у каждого приличного гнома есть `fatherName`, то есть имя отца (Торин, сын Траина). Также, у гнома есть свойство `stamina`, которое содержит показатель выносливости гнома. Его не нужно передавать как аргумент конструктора - потому что оно будет 100 единиц по умолчанию.
4. Определяем методы. Хоббиты недурно умеют бросать каштаны - научим наших хоббитов бросаться каштанами. Но не нужно забывать, что количество каштанов ограничено. Поэтому, добавим хоббиту свойство `chestnuts`, где будем хранить число каштанов, которое есть у хоббита. И добавим методы
  - `getChestnuts(chestnutsCnt)` - хоббит собирает каштаны. Аргумент - количество каштанов
  - `throwChestnut` - хоббит бросает один каштан, соответственно, счетчик его каштанов уменьшается.
5. Гномы же умеют бить врагов. Создадим гномам метод `attack`, он выводит в консоль текст `Dwarf _NAME_ attacks!`. Это не бесплатно - у гномов есть показатель выносливости (`stamina`), и он падает с каждой атакой на 5 единиц. Если показатель выносливости меньше 10 единиц - гном атаковать не будет (выводим в консоль сообщение `The dwarf _NAME_ is too tired, hill him ASAP!`).
6. Добавим гному восстановление выносливости. Реализуйте метод `hill`. Он принимает в аргументах еду или напиток, который употребит гном для восстановления своей выносливость. Лучше всего гномам помогают эль (`ale`) и мясо (`meat`). Если аргумент один из этих - то восстанавливаем гному 10 очков выносливости. Если нет - то восстанавливаем случайное количество очков выносливости, от 1 до 10.
7. Давайте расширим иерархию классов. У нас в игре, присутствует клан гномов-воинов - каждому воину характерно его основное оружие (свойство `primaryWeapon`, содержит строку), и броня (свойство `armour` - массив с именами вещей). Также, у нас есть клан гномов-кузнецов, в чьи задачи входит создавать оружие. Они не носят вооружения и брони, зато у каждого из них есть инструменты (массив `tools`), и свойство `forgerSkill` - число, которое отвечает за уровень владения кузнечным навыком. Задача к обсуждению.


### Полиморфизм
Теперь, после того как мы поговорили о наследовании, и умеем расширять функциональность классов, пора поговорить о полиморфизме. Если вкратце - это способность потомков по-разному реализовывать методы, которые есть у родителя. Сразу оговоримся: с учетом ограничений JS, ощутить всю мощь полиморфизма не получится. Это реально в TS, Java, C# и прочих действительно объектно-ориентированных языках. Но посмотрим, что нам дает наш язык.

Мы сказали, что это способность потомков делать конкретную реализацию методов родителей. Что же имеется в виду? В нашей архитектуре классов для животных, мы говорили, что каждое животное издает звуки. Определим в классе `Animal`, метод `makeSound`, который будет просто сообщать о том, что животное издает звук.

```
class Animal {

   constructor(name, weight) {
      this.name = name;
      this.weight = weight;
   }

   makeSound() {
      console.log(`Animal ${this.name} says something.`);
   }
}
```

Теперь посмотрим на остальные классы. И собака, и попугай умеют издавать звуки. Но собака лает, а попугай может чирикать, а может и говорить слова (если он это умеет). Давайте скажем, что и собака, и попугай также издают звуки, но каждый это делает на свой манер.

```
class Animal {

   constructor(name, weight) {
      this.name = name;
      this.weight = weight;
   }
}

class Dog extends Animal {

   constructor(name, weight, kind) {
      super(name, weight); // вызываем конструктор родителя, то есть создаем объект "Животное"
      // После вызова конструктора родителя, мы определяем свойства объекта именно этого класса (то есть те свойства,
      // которые не представлены в родителе)
      this.kind = kind;
   }

   makeSound() {
      console.log(`The dog says BARK! Who let the dog out! Bark! Bark!`);
   }
}

class Parrot extends Animal {

   constructor(name, weight, canSpeak) {
      super(name, weight); // вызываем конструктор родителя, то есть создаем объект "Животное"
      // После вызова конструктора родителя, мы определяем свойства объекта именно этого класса (то есть те свойства,
      // которые не представлены в родителе)
      this.canSpeak = canSpeak;
   }

   makeSound() {
      if (this.canSpeak) {
         console.log(`The parrot says "Whats up, doc???"`);
      } else {
         console.log('The parrot says "Tweet"');
      }
   }
}
```

То есть, и собака, и попугай умеют издавать какие-то звуки, но каждый делает это по-своему. Это и есть полиморфизм, когда потомок сам определяет, как он будет выполнять функциональность из класса-родителя. Разумеется, это далеко не вся мощь полиморфизма, но в JS нам этого более чем достаточно.

**Еще немного о `super`**
Теперь, зададим себе вопрос, а что если мы при реализации метода `makeSound` хотим не только реализовать нашу функциональность, но и вызвать ту реализацию метода, которая есть у родителя? То есть сначала сказать "Животное издает звук", а затем уже конкретный звук. Вот тут нам на помощь опять приходит ключевое слово `super`.
```
class Dog extends Animal {

   constructor(name, weight, kind) {
      super(name, weight); // вызываем конструктор родителя, то есть создаем объект "Животное"
      // После вызова конструктора родителя, мы определяем свойства объекта именно этого класса (то есть те свойства,
      // которые не представлены в родителе)
      this.kind = kind;
   }

   makeSound() {
      // вызываем метод из родителя
      super.makeSound();
      // делаем свою, "собачью" реализацию
      console.log(`The dog says BARK! Who let the dog out! Bark! Bark!`);
   }
}
```

То есть, делаем еще один важный вывод относительно слова `super`. Это слово "едино в двух лицах":
 - внутри конструктора, оно указывает на КОНСТРУКТОР класса-родителя
 - внутри методов, оно указывает на ОБЪЕКТ класса-родителя.

**Закрепим практикой**
1. Продолжаем работать в контексте нашей игры. У нас, в нашем классе `Human`, определен метод `greet`. Давайте научим хоббитов и гномов здороваться. Хоббит должен говорить "Hi, stranger, I am hobbit from _HOME_VILLAGE_". Гном должен говорить "Hi, friend, I am dwarf, son of _FATHER_NAME_".
2. Теперь пусть и хоббит, и гном говорят свое имя. Хоббит должен говорить "Hi, stranger, I am hobbit _NAME_ from _HOME_VILLAGE_". Гном должен говорить "Hi, friend, I am dwarf _NAME_, son of _FATHER_NAME_".
3. Теперь, пусть и хоббит, и гном, при приветствии вызывают метод родителя (тоже через `super`).
4. Теперь научите здороваться гномов-воинов. Реализуйте в этом классе метод `greet` так, чтобы он выводил в консоль и обычный текст приветствия гнома (т.е. реализацию из метода родителя), и еще дополнительно выводил бы текст `I am warrior, my primary weapon is _PRIMARY_WEAPON_`.
5. Теперь вспомним асинхронность. Гномы-кузнецы умеют ковать оружие. Добавьте им метод `forge`, которы будет принимать имя оружия, которое должен отковать гном. Ковка - процесс небыстрый, поэтому сделайте так, чтобы метод возвращал бы результат не сразу, а через случайное количество секунд (от 0 до 5).
6. Иногда, кузнецов просят не только отковать, но еще и закалить оружие. Добавьте метод `harden`, который примет 2 аргумента. Первый - это имя оружия, которое нужно закалить. Второй - `shouldForge`, флаг, надо ли его отковать или оно уже готово. Если второй аргумент - true, то нужно сначала отковать это оружие, затем закалить его. Иначе - просто закалить. Закалка - тоже длительный процесс, и должен занять от 0 до 5 секунд.
7. Собираемся в поход. Создайте 3 экземпляра класса "Dwarf". Это три гнома которые будут ковать оружие для Торина. Первый должен отковать меч, второй - щит, а третий - броню (sword, shield, armour). Нужно дождаться, пока все мастера завершат свою работу, и потом вывести в консоль сообщение "I am ready, and I have _НАЗВАНИЯ_ВООРУЖЕНИЙ_".

### Полезные ссылки
 - Русскоязычный гайд по основам [ООП](https://learn.javascript.ru/class). Уже можно читаить весь раздел учебника.
 - Приватные свойства и методы. [Учебник](https://learn.javascript.ru/private-protected-properties-methods).
 - Еще один гайд по [ООП](https://proglib.io/p/uchebnik-po-javascript-oop-na-prostyh-primerah-2022-06-26). Теперь можно читать и раздел про наследование.