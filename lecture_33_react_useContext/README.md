# README

## Лекционное занятие №33

### Тема:

Репозитарий содержит материалы по занятию, посвященному хуку `useContext`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Зачем это нужно
Сегодня мы будем говорить о хуке `useContext`, который нужен для работы с контекстом (логично, не так ли?). Прежде чем говорить непосредственно о хуке, попробуем дать определение понятию контекста.

Мы уже знакомы с контекстом, ранее мы говорили о контексте, когда обсуждали ключевое слово `this`. И также мы упоминали его при обсуждении понятия замыканий. Что же такое контекст в рамках React-приложения, и какие проблемы он может помочь решить?

Контекст в React-приложении - это тоже нечто "внутри чего" работают другие компоненты. Это "нечто" предоставляет своим потребителям (подписчикам), доступ к каким-то данным (собственно, контексту).

Какие проблемы решаются с помощью контекста? Те же, которые мы решали подъемом состояния. А также еще одна проблема, `prop drilling`, которую мы сегодня и обсудим.

### Мотивация использования контекста
Ранее, если нам нужно было разделить состояние между компонентами, мы просто "поднимали" состояние до уровня ближайшего общего предка, и прокидывали его через пропсы в потребителей. Такой способ хорош, когда у нас небольшая иерархия компонентов. А давайте предположим следующее. У нас есть более сложная иерархия компонентов:
 -> App
    | -> TodoList
    |    | -> TodoCard
    |         | -> Button
    | -> AddTodo
         | -> InputField
         | -> Button

При этом, наши "визуальные компоненты", то есть InputField и Button, должны иметь общую тему. Напрашивается решение - поднять эту тему на уровень общего предка. Ближайшим общим предком будет компонент `App`.

Что же получится в этом случае? А получится то, что нам придется прокидывать значение темы через всю иерархию компонентов, в том числе и через тех, которые ее не используют. То есть,
 - App -> TodoList -> TodoCard -> Button,
 - App -> AddTodo -> InputField, Button

Промежуточным компонентам (TodoList, TodoCard, AddTodo), эта тема вообще не нужна - она нужна только кнопке и инпуту. Но мы все равно вынуждены передавать тему через эти компоненты. Такая проблема (когда необходимые данные пробрасываются через всю иерархию компонентов), называется `prop drilling`.

И одним из способов избежать эту проблему, является как раз хук `useContext`, который позволяет "прицельно" передать какие-то данные на любой уровень иерархии компонентов. По сути, очень похоже на `useState`, только уже не на уровне одного компонента.

### Использование контекста
Использование контекста подразумевает несколько шагов.
1. Создание контекста. В рамках этого шага, мы создадим сам контекст, который будет содержать данные, которые мы хотим передать потребителям. Делается это с помощью функции `createContext`. Такие штуки рекомендуется делать в отедльном компоненте.

```
// file src/context/ThemeContext.jsx
import { createContext } from 'react';

export const ThemeContext = createContext('light');
```

Мы просто создаем контекст вызовом функции `createContext`. Аргументом этой функции будет начальное значение контекта.

2. Использование контекста потребителями. На этом шаге, мы указываем, какие потребители будут использовать наш контекст, и как.

```
// file src/components/button/Button.jsx
import { useContext } from 'react';
import { ThemeContext } from '../../context/ThemeContext.jsx';

export default function Button( {btnText, clickHandler} ) {

  const themeName = useContext(ThemeContext);

  const styleObj = {
    color: themeName === 'light' ? 'darkblue' : 'white',
    backgroundColor: themeName === 'light' ? 'lightskyblue' : 'darkblue',
  }
  return (
    <button onClick={clickHandler} style={styleObj}>{btnText}</button>
  )
}
```

То есть, мы говорим, что наш компонент (Button), является потребителем контекста `ThemeContext`. Это важно, потому что приложение запросто может иметь несколько контекстов. В самом компоненте, мы говорим, что значение из нашего контекста (имя темы), мы хотим использовать для определения цвета текста и цвета фона кнопки. Разумеется, стили лучше выносить в CSS-модуль, но сейчас сделано так для наглядности.

3. Провайдер контекста. Нам остался завершающий шаг - создание провайдера контекста. Это нечто, во что мы "обернем" ту часть нашего приложения, которая должна будет работать с контекстом. По сути, очень похоже на подъем состояния - только теперь, вместо применения `useState` в общем предке, мы применяем провайдер контекста в общем предке. Если мы этого не сделаем - то потребители контекста (в нашем случае, `Button`), кинут нам ошибку.

```
// App.js
// ... some other imports
import { ThemeContext } from './context/ThemeContext';

function App() {
  // hooks, functions, etc.

  return (
    <div className="App simpleStyle">
      <ThemeContext.Provider value='light'>
        <TodoList todos={todos} dropTodoById={dropTodoById} checkTodo={checkTodo}/>
        <Copyright/>
      </ThemeContext.Provider>
    </div>
  );
}

export default App;
```

То есть, мы импортируем наш контекст, и используем его встроенное свойство `Provider`, для того, чтобы создать компонент-обертку. В эту обертку мы упаковываем ту часть приложения, которая будет работать с контекстом. Важный момент - этот провайдер ожидает от нас проп `value` - то есть, значение контекста. Туда можно положить все, что угодно - примитив, объект, функцию - в общем, все.

Собственно, так все и работает. Можно попробовать изменить `light` на `dark` в пропе value - и наши кнопки перерисуются.

Если нам нужно будет добавить другие потребители контекста - то мы сделаем это точно так же, как с компонентом `Button`.

Может возникнуть вопрос: а где используется значение, которое мы задавали в `createContext` в файле `ThemeContext.jsx`? Это т.н. fallback, то есть это значение будет использовано, если мы не зададим проп `value` при создании провайдера контекста.

**Закрепим практикой**
Создадим простой контекст для счетчика. Нам нужно создать сам контекст, с начальным значением 0. В качестве потребителя контекста, создадим компонент `SimpleCounter`, который будет выводить параграф со значением счетчика. Этот компонент надо отрисовать в компоненте `App`, над списком дел.

### Дальнейшие шаги
Просто использовать статичный контекст, который никак не будет изменяться, скучно. Обычно, нужно чтобы контекст как-то менялся в приложении, и при этом чтобы приложение реагировало на смену контекста - например, мы хотим менять тему приложения, и хотим, чтобы наши потребители контекста это учитывали (при нажатии на "смена темы", мы хотим перерисовки приложения). Поэтому, контекст очень часто используется в комбинации со стейтом. Давайте попробуем это реализовать.

```
function App() {

  // ...

  const [theme, setTheme] = useState('light');
  const switchTheme = () => {
    setTheme( old => old === 'light' ? 'dark' : 'light');
  }

  return (
    <div className="App simpleStyle">
      <ThemeContext.Provider value={theme}>
        <p>Now selected theme is: {theme}</p>
        <button onClick={switchTheme}>Change theme</button>
        <TodoList todos={todos} dropTodoById={dropTodoById} checkTodo={checkTodo}/>
        <Copyright/>
      </ThemeContext.Provider>
    </div>
  );
}

export default App;
```

То есть, у нас теперь на уровне компонента `App`, создан фрагмент локального стейта, который хранит в себе значение темы. При изменении этого, компонент (и все его потомки), будут перерисованы, уже с актуальным значением темы.

**Закрепим практикой**
Реализуйте аналогичное поведение для счетчика - перенесите его значение в локальный стейт компонента `App`, и добавьте там же кнопки для увеличения/уменьшения счетчика.

### Последние штрихи - вынос стейта в контекст
Однако, наши компоненты все еще не особо хорошо выглядят. Ведь у нас сам контекст - в одном месте, а средство его управления в другом. Это не особо логично выглядит. Попробуем исправить. Было бы здорово, если бы этот фрагмент локального состояния (и средство управления им), были бы не в `App`, а в файле контекста. Давайте попробуем доработать наш `ThemeContext`. Попробуем перенести в него создание провайдера контекста с уже необходимыми нам данными и инструментами для управления.

```
import { createContext } from 'react';

// по-прежнему экспортируем контекст - он нам понадобится в потребителях
export const ThemeContext = createContext('light');

// создаем уже готовый к употреблению провайдер контекста.
export function ThemeContextProvider( {children} ) {

  const [theme, setTheme] = useState('light');
  const switchTheme = () => {
    setTheme( old => old === 'light' ? 'dark' : 'light');
  }

  return (
    <ThemeContext.Provider value={{theme: theme, switchTheme: switchTheme}}>
      {children}
    </ThemeContext.Provider>
  )
}
```

Что мы имеем по итогу? Мы создали "готовый к употреблению" провайдер контекста, который будет оборачивать своих потомков (children) в провайдера контекста ThemeContext. При этом, в роли value, мы будем передавать потребителям ОБЪЕКТ, который будет содержать свойство `theme`, где будет собственно значение темы, и свойство `switchTheme`, где будет инструмент по переключению темы. То есть, мы инкапсулировали всю логику по работе с контекстом в нашем компоненте!

Нам осталось только переписать потребителей. Ранее, наши потребители ожидали в контексте строку, а теперь там будет объект. В случае с `Button` все просто. А вот с `App` похуже. Нам нужно удалить локальный стейт, а вместо него указать хук `useContext` - то есть теперь `App` становится потребителем контекста.

```
function App() {

  // other hooks, logic, ...

  const ctx = useContext(ThemeContext);

  return (
    <div className="App simpleStyle">
        <p>Now selected theme is: {ctx.theme}</p>
        <button onClick={ctx.switchTheme}>Change theme</button>
        <TodoList todos={todos} dropTodoById={dropTodoById} checkTodo={checkTodo}/>
        <Copyright/>
    </div>
  );
}
```

И также обратите внимание, что из return удален провайдер контекста. Это сделано потому, что App теперь является потребителем контекста, и нам нужно сделать так, чтобы компонент `App` был обернут в наш контекст. Поэтому использование нашего провайдера мы перенесем на уровень выше, в `index.js`.

```
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App.js';
import { ThemeContextProvider } from './context/ThemeContext.jsx';


const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(

  <ThemeContextProvider>
    <App />
  </ThemeContextProvider>
);
```

Теперь мы обернули в провайдер контекста все наше приложение. В этом нет ничего страшного.

**Закрепим практикой**
Реализуйте аналогичные изменения для контекста счетчика `Counter`. Нужно, чтобы тоже создавался провайдер `CounterContextProvider`, который будет передавать потребителям объект со значением счетчика и инструментами для его инкремента/декремента.



### Полезные ссылки
[Пошаговое использование контекста](https://react.dev/learn/passing-data-deeply-with-context#) - с подробными описаниями шагов.
[Хук useContext](https://react.dev/reference/react/useContext) - информативно, с интерактивными примерами.