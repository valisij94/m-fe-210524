# README

## Лекционное занятие №17

### Тема:

Репозитарий содержит материалы по лекционному занятию №17, посвященному работе с синтаксисом async/await.

**Зачем это нужно**
Синтаксис *async/await* используется при работе с промисами. Это удобная и более короткая (по сравнению с then) форма записи. На практике этот синтаксис применяется очень широко, но полностью забывать стандартный синтаксис промисов тоже не следует.

**Что такое async**
Это ключевое слово, которым мы можем "пометить" функцию. Его пишут перед словом `function`, или перед круглыми скобками если функция стрелочная. Когда мы помечаем функцию как асиинхронную, это **гарантирует** что функция будет возвращать промис. То есть, функция станет асинхронной, и что бы она нам ни возвращала - нам нужно дождаться результата выполнения.

Причем, очень важно понимать, что НЕЗАВИСИМО от того, что у нас указано в `return`-е нашей функции, это что-то будет обернуто в промис.

```
async function myAsyncFunction() {
   return 104;
}

const resultFirst = myAsyncFunction();
console.log(resultFirst); // Promise<pending>

resultFirst().then( r => console.log(r) ); // 104
```

То есть мы видим, что если мы добавили слово `async` перед именем функции, то ее возвращаемое значение будет обернуто в промис. И с результатом этой функции мы можем работать только как с результатом промиса.

Рассмотрим пример для стрелочной функции.
```
const arrowAsync = async () => {
   return 98;
}

const resultFirst = arrowAsync();
console.log(resultFirst); // Promise<pending>

arrowAsync().then( r => console.log(r) ); // 98
```

Таким образом, мы делаем вывод, что если мы помечаем функцию как асинхронную, то она начинает себя вести как асинхронная, то есть ее результат будет обернут в промис, и для работы с результатом, нам нужно дождаться окончания выполнения этой функции.

**Ключевое слово await**
Логичный вопрос, а зачем нам нужен `async`, если можно просто вернуть из функции промис? И вот тут начинается самое интересное. В паре с `async`, обычно используется ключевое слово `await`, которое как бы говорит, что скрипт должен дождаться выполнения промиса, и только после этого двигаться дальше.

Рассмотрим пример.

```
async function requestSomething() {
   // мы помним, что fetch нам возвращает промис
   const httpResponse = await fetch('https://dummyjson.com/products);
   // JavaScript дождется, пока выполнится промис справа от await, и только потом
   // пойдет к следующей команде
   const parsedResponse = await httpResponse.json();
   // Тоже дожидаемся выполнения промиса json(), и только после этого идем дальше
   return parsedResponse; // этим будет зарезолвлен тот промис, который вернет функция
}
```

И теперь, у нас есть асинхронная функция, которая выполняет какие-то асинхронные действия, дожидается результата, и потом дает нам возможность работать с этим результатом. Фактически, это очень напоминает одну из задач, которые решались нами ранее - когда мы писали функцию, которая возвращала промис, который был бы зарезолвлен результатом ответа от бэка.

Бытует мнение, что `async/await` - это синтаксический сахар для работы с промисами, более наглядный и понятный чем then.

**Ограничения при использовании**
Ничто не дается даром - поэтому нельзя просто взять и использовать слово `await` там, где хочется.
1. `await` может быть применен только внутри функции (то есть, на уровне скрипта мы его не применим).
2. `await` может быть применен только внутри АСИНХРОННОЙ функции, то есть функции, помеченной как `async`.

**Закрепим практикой**
1. Пристрелочная задача. Написать асинхронную функцию, которая будет обращаться за списком товаров по адресу `https://dummyjson.com/products`, и выводит результат консоль. Использовать синтаксис async/await.
2. Написать функцию `simplePromise`. Она должна создавать промис, который будет зарезолвлен через 3 секунды словом 'Success'.
3. Написать функцию `useSimplePromise`, она должна быть асинхронной. Нужно внутри этой функции вызвать функцию `simplePromise`, дождаться результата, и вывести результат в консоль.
4. Написать функцию `promiseFactory`, которая будет создавать промисы. В аргументах она принимает `isSuccess`, `timeout`, `promiseResult`. Функция должна создать промис. Если `isSuccess = true`, то через `timeout` секунд промис должен быть зарезолвлен аргументом `promiseResult`. А если `isSuccess = false`, то через `timeout` секунд нужно вызвать `reject` с `promiseResult`.
5. Написать функцию `sendProtectedData`. Она примет в аргументе строку. Нужно "зашифровать" эту строку вызовом функции `encryptData`, дождаться результата, и отправить результат вызовом функции `makeRequest`. Дождаться результата, и вернуть его из этой функции.

**Обработка нештатных ситуаций**
Возникает (надеюсь), логичный вопрос: а как быть с нештатными ситуациями при использовании синтаксиса `async/await`? Ведь ранее у нас были `catch`, `finally`, а что же делать теперь?

Ответ: использовать стандартный механизм обработки исключений, о котором нам предстоит поговорить сейчас.

Для начала, введем понятие "исключение". Это некоторая нештатная ситуация, которая возникла во время выполнения нашего кода. Например, в ходе выполнения мы попробовали обратиться к свойству какого-то объекта, а вместо этого объекта у нас `undefined`. Или мы пытаемся обратиться к несуществующей переменной. И так далее. Такого рода казусы именуются исключениями. Потому что JS не может решить проблему самостоятельно. И поэтому, JS прерывает выполнение скрипта, и "бросает исключение" - то есть как бы говорит "я сделал все что мог, с этим я справиться не могу, сделайте что-нибудь". И далее, или это исключение перехватит наш код (если мы об этом позаботились), или же его перехватит обработчик по умолчанию. Это тот самый вредитель, который в такой ситуации пишет нам в консоль красные сообщения.

```
const fakeObj = null;
// мы обращаемся к свойству несуществующего объекта - будет исключение
console.log(fakeObj.fakeProperty);
// сюда скрипт не дойдет, это сообщение мы в консоли не увидим
console.log('Will not be printed');
```

То есть, мы видим, как ведет себя браузер, когда он с чем-то не может справиться.

Но мы можем с этим побороться. Если мы знаем, что у нас в коде есть опасное место (то есть там может возникнуть какая-нибудь исключительная ситуация), то мы можем как бы сказать "эй, джаваскрипт, ПОПРОБУЙ выполнить этот фрагмент кода. Если не получится - сделай такие-то действия".
```
try {
   const fakeObj = null;
   // мы обращаемся к свойству несуществующего объекта - будет исключение
   console.log(fakeObj.fakeProperty);
   // сюда скрипт не дойдет, это сообщение мы в консоли не увидим
   console.log('Will not be printed');
}
catch (err) {
   console.log('Something went wrong');
}

console.log('This will be printed!');
```

Если мы запустим фрагмент кода, то мы увидим сообщение из блока `catch`, и потом сообщение из последней строки. Сообщение `Will not be printed` мы также не увидим. Почему так? Потому что, когда в блоке `try` возникает ошибка, то JS прерывает выполнение, генерирует объект исключения, и передает управление в ближайший блок `catch`.

То есть, мы видим, что мы можем оборачивать потенциально опасные блоки кода в `try-catch`, и как бы подстраховываться от поломки. Разумеется, от самой нештатной ситуации это нас не убережет, но мы хотя бы можем попробовать обработать ее, и наш скрипт продолжит выполнение - а не "все сломалось".

**Закрепим практикой**
1. Есть блок опасного кода, который вызывает несуществующую функцию.
```
console.log('Calling undefined function');
const result = nonDefinedFunction();
console.log('Final');
```
Оберните его в `try-catch`, и в случае возникновения нештатной ситуации, выводите в консоль текст `Something went wrong!`.

2. Есть фрагмент опасного кода. Оберните в `try-catch` только то, что считаете нужным. И в случае нештатных ситуаций, выводите в консоль сообщение `Whoops!`.
```
const rand = Math.random();
const res = rand < 0.5 ? function() { console.log('Hehehe'); } : null;
res();
console.log('And thats all, folks!');
```


**Что такое исключение, или что мы ловим**
Еще существенный момент, о котором стоит упомянуть - это объект исключения. Каждая нештатная ситуация содержит какую-то информацию. Обычно это код ошибки и сообщение об ошибке. И это все есть в том объекте, который будет пойман `catch`-ем.
```
try {
   const fakeObj = null;
   // мы обращаемся к свойству несуществующего объекта - будет исключение
   console.log(fakeObj.fakeProperty);
   // сюда скрипт не дойдет, это сообщение мы в консоли не увидим
   console.log('Will not be printed');
}
catch (err) {
   console.dir(err);
}
```

В этом случае, мы видим объект, у которого есть свойства `message` (сообщение об ошибке), и `stack` - стек вызовов, который привел к этой ошибке (это нужно для отладки). Для того, чтобы плюс-минус показать пользователю, что произошло, нам обычно хватит текста ошибки (message).

**Пользовательские исключения**
Пользователи могут создавать свои исключения. То есть, сами создавать себе проблемы и геройски их решать (спойлер - нет). Суть в том, что в любом программном коде могут быть исключительные ситуации, характерные только для этого проекта. Ну например, если бы мы писали функцию нахождения расстояния между двумя точками, и нам бы не передали координаты второй - это ведь характерно только для нашей функции, и нашего проекта. И мы в этом случае можем сгенерировать свое, пользовательское, исключение со своим пояснительным текстом, и "бросить" его, чтобы уведомить вызывающий код о том, что что-то пошло не так. Для создания своего исключения используем конструктор:
```
const myError = new Error('This is my error!');
```

А для того, чтобы его бросить (то есть сказать, что нечто идет не так), есть слово `throw`.
```
function getDistance(x1, y1, x2, y2) {
   if ((x2 !== 0 && !x2) || (y2 !== 0 && !y2)) {
      throw new Error('Incorrect second point!');
   }
   return Math.sqrt( Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2));
}

console.log(getDistance(0, 0, 3, 3));
console.log(getDistance(0, 0));
```

**Finally**
И есть еще блок `finally`, который по сути аналогичен такому же блоку с промисами - он будет выполнен ВСЕГДА, вне зависимости от того, прошла ли исключительная ситуация в блоке `try`, или все прошло гладко.
```
try {
   console.log('Start');
   const r = Math.random();
   if (r < 0.5) {
      throw new Error('Simple error');
   }
   console.log('Finishing try block successfully');
}
catch (err) {
   console.log('something went wrong', err.message);
}
finally {
   console.log('Will be shown in all cases');
}
```

**Закрепим практикой**
1. Пристрелочная. Написать функцию `smartSqrt` - она принимает на вход аргумент. Если аргумент больше либо равен 0 - то возвращает его квадратный корень. Иначе - нужно сгенерировать свое исключение с текстом "Не удалось извлечь квадратный корень!".
2. Вызвать написанную функцию для аргумента -9. Перехватить ошибку, и вывести в консоль сообщение ошибки.

**Использование async/await + try-catch**
И теперь пришла пора все объединить. Для работы с нештатными ситуациями в async/await, нам как раз и поможет try-catch! То есть, нам нужно оборачивать потенциально опасный код в безопасный блок.
```
async function makeRequest(url) {
   try {
      const resp = await fetch(url);
      const parsed = await resp.json();
      return parsed;
   }
   catch(err) {
      console.log('Something went wrong');
      return false;
   }
}
```

Теперь, если у нас что-то пойдет не так при отправке запроса, функция просто вернет `false`. Разумеется, на практике так никто не поступает, но для примера сойдет.

### Полезные ссылки
 - Русскоязычный гайд [async/await](https://learn.javascript.ru/async-await).
 - Спецификация [try-catch](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch) на MDN - местами русскоязычная.
 - Русскоязычный гайд [try-catch](https://learn.javascript.ru/try-catch).